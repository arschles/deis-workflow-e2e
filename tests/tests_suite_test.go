package tests

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	neturl "net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/deis/workflow-e2e/apps"
	"github.com/deis/workflow-e2e/controller"
	. "github.com/onsi/ginkgo"
	"github.com/onsi/ginkgo/reporters"
	. "github.com/onsi/gomega"
	. "github.com/onsi/gomega/gbytes"
	. "github.com/onsi/gomega/gexec"
)

type Cmd struct {
	Env               []string
	CommandLineString string
}

type App struct {
	Name string
	URL  string
}

type TestData struct {
	Username      string
	Password      string
	Email         string
	KeyName       string
	KeyPath       string
	Profile       string
	ProfilePath   string
	ControllerURL string
}

var (
	adminTestData                       TestData
	testRoot, testHome, keyPath, gitSSH string
	appNameSet                          = apps.NewSet()
	debug                               = os.Getenv("DEBUG") != ""
	homeHome                            = os.Getenv("HOME")
	defaultMaxTimeout                   = getDefaultMaxTimeout()
	errMissingRouterHostEnvVar          = fmt.Errorf("missing %s", deisRouterServiceHost)
	adminDeisClient                     *controller.Client
	testDeisClient                      *controller.Client
)

const (
	deisRouterServiceHost = "DEIS_ROUTER_SERVICE_HOST"
	deisRouterServicePort = "DEIS_ROUTER_SERVICE_PORT"
)

func getDir() string {
	_, filename, _, _ := runtime.Caller(1)
	return path.Dir(filename)
}

func getDefaultMaxTimeout() time.Duration {
	value := os.Getenv("DEFAULT_MAX_TIMEOUT")
	if value == "" {
		return 600 * time.Second
	}
	timeout, _ := time.ParseDuration(value)
	return timeout
}

func getDefaultEventuallyTimeout() time.Duration {
	value := os.Getenv("DEFAULT_EVENTUALLY_TIMEOUT")
	if value == "" {
		return 60 * time.Second
	}
	timeout, _ := time.ParseDuration(value)
	return timeout
}

func init() {
	rand.Seed(time.Now().UnixNano())
}

func getRandAppName() string {
	return fmt.Sprintf("test-%d", rand.Intn(999999999))
}

func TestTests(t *testing.T) {
	RegisterFailHandler(Fail)

	enableJunit := os.Getenv("JUNIT")
	if enableJunit == "true" {
		junitReporter := reporters.NewJUnitReporter(filepath.Join(homeHome, "junit.xml"))
		RunSpecsWithDefaultAndCustomReporters(t, "Deis Workflow", []Reporter{junitReporter})
	} else {
		RunSpecs(t, "Deis Workflow")
	}
}

var _ = BeforeSuite(func() {
	SetDefaultEventuallyTimeout(getDefaultEventuallyTimeout())

	// use the "deis" executable in the search $PATH
	output, err := exec.LookPath("deis")
	Expect(err).NotTo(HaveOccurred(), output)

	testHome, err = ioutil.TempDir("", "deis-workflow-home")
	Expect(err).NotTo(HaveOccurred())
	os.Setenv("HOME", testHome)

	controllerURL := getController()
	adminClient = controller.NewClient(controllerURL, 1000, false)
	// register the admin user
	_, adminErr := controller.RegisterOrLogin(adminClient, "admin", "admin", "admintest@deis.com")
	Expect(adminErr).To(BeNil())
	profilePath := loginHTTP(getController(), "admin", "admin")
	adminTestData.Profile = "admin"
	adminTestData.Username = "admin"
	adminTestData.Password = "admin"
	adminTestData.ControllerURL = getController()
	adminTestData.ProfilePath = profilePath

	// verify this user is an admin by running a privileged command
	sess, err := start("deis users:list", adminTestData.Profile)
	Eventually(sess).Should(Exit(0))
	Expect(err).NotTo(HaveOccurred())
})

var _ = BeforeEach(func() {
	var err error
	var output string

	testRoot, err = ioutil.TempDir("", "deis-workflow-test")
	Expect(err).NotTo(HaveOccurred())

	os.Chdir(testRoot)
	output, err = execute(`git clone https://github.com/deis/example-go.git`)
	Expect(err).NotTo(HaveOccurred(), output)
	output, err = execute(`git clone https://github.com/deis/example-perl.git`)
	Expect(err).NotTo(HaveOccurred(), output)
})

var _ = AfterSuite(func() {
	os.Chdir(testHome)
	os.Setenv("HOME", homeHome)
	deleteSuccCh := make(chan apps.Name)
	deleteErrCh := make(chan error)
	deleteDoneCh := make(chan struct{})
	go apps.DeleteAll(appNameSet.GetAll(), deleteSuccCh, deleteErrCh, deleteDoneCh)
	for {
		select {
		case appName := <-deleteSuccCh:
			fmt.Fprintf(GinkgoWriter, "successfully deleted app namespace %s", appName)
		case err := <-deleteErrCh:
			fmt.Fprintf(GinkgoWriter, "error deleting app namespace (%s)", err)
		case <-deleteDoneCh:
			break
		}
	}
})

func logout() {
	sess, err := start("deis auth:logout", "")
	Expect(err).To(BeNil())
	Eventually(sess).Should(Exit(0))
	Expect(err).NotTo(HaveOccurred())
	Eventually(sess).Should(Say("Logged out\n"))
}

// execute executes the command generated by fmt.Sprintf(cmdLine, args...) and returns its output as a cmdOut structure.
// this structure can then be matched upon using the SucceedWithOutput matcher below
func execute(cmdLine string, args ...interface{}) (string, error) {
	var cmd *exec.Cmd
	shCommand := fmt.Sprintf(cmdLine, args...)

	if debug {
		fmt.Println(shCommand)
	}

	cmd = exec.Command("/bin/sh", "-c", shCommand)
	outputBytes, err := cmd.CombinedOutput()

	output := string(outputBytes)

	if debug {
		fmt.Println(output)
	}

	return output, err
}

func start(cmdLine string, profile string, args ...interface{}) (*Session, error) {
	if profile != "" {
		envVars := append(os.Environ(), fmt.Sprintf("DEIS_PROFILE=%s", profile))
		ourCommand := Cmd{Env: envVars, CommandLineString: fmt.Sprintf(cmdLine, args...)}
		return startCmd(ourCommand)
	}
	ourCommand := Cmd{Env: os.Environ(), CommandLineString: fmt.Sprintf(cmdLine, args...)}
	return startCmd(ourCommand)
}

func startCmd(command Cmd) (*Session, error) {
	cmd := exec.Command("/bin/sh", "-c", command.CommandLineString)
	cmd.Env = command.Env
	io.WriteString(GinkgoWriter, fmt.Sprintf("$ %s\n", command.CommandLineString))
	return Start(cmd, GinkgoWriter, GinkgoWriter)
}

func createKey(username string, name string) string {
	keyPath := path.Join(testHome, username, ".ssh", name)
	os.MkdirAll(path.Join(testHome, username, ".ssh"), 0777)
	if _, err := os.Stat(keyPath); os.IsNotExist(err) {
		sess, err := start("ssh-keygen -q -t rsa -b 4096 -C %s -f %s -N ''", "", name, keyPath)
		Expect(err).To(BeNil())
		Eventually(sess).Should(Exit(0))
		Expect(err).NotTo(HaveOccurred())
	}

	os.Chmod(keyPath, 0600)

	return keyPath
}

func getController() string {
	host := os.Getenv(deisRouterServiceHost)
	if host == "" {
		errStr := fmt.Sprintf(`Set the router host and port for tests, such as:

$ %s=192.0.2.10 %s=31182 make test-integration`, deisRouterServiceHost, deisRouterServicePort)
		log.Println(errStr)
		os.Exit(1)
	}
	// Make a xip.io URL if DEIS_ROUTER_SERVICE_HOST is an IP V4 address
	ipv4Regex := `^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$`
	matched, err := regexp.MatchString(ipv4Regex, host)
	if err != nil {
		log.Printf("Error: Invalid router service host %s (%s)", host, err)
		os.Exit(1)
	}
	if matched {
		host = fmt.Sprintf("deis.%s.nip.io", host)
	}
	port := os.Getenv(deisRouterServicePort)
	switch port {
	case "443":
		return "https://" + host
	case "80", "":
		return "http://" + host
	default:
		return fmt.Sprintf("http://%s:%s", host, port)
	}
}

// getRawRouter returns the URL to the deis router according to env vars.
//
// Returns an error if the minimal env vars are missing, or there was an error creating a URL from them.
func getRawRouter() (*neturl.URL, error) {
	host := os.Getenv(deisRouterServiceHost)
	if host == "" {
		return nil, errMissingRouterHostEnvVar
	}
	portStr := os.Getenv(deisRouterServicePort)
	switch portStr {
	case "443":
		return neturl.Parse(fmt.Sprintf("https://%s", host))
	case "80", "":
		return neturl.Parse(fmt.Sprintf("http://%s", host))
	default:
		return neturl.Parse(fmt.Sprintf("http://%s:%s", host, portStr))
	}
}

func createApp(profile string, name string, options ...string) *Session {
	var noRemote = false
	sess, err := start("deis apps:create %s %s", profile, name, strings.Join(options, " "))
	Expect(err).NotTo(HaveOccurred())
	sess.Wait(defaultMaxTimeout)
	Eventually(sess).Should(Say("created %s", name))

	existed := appNameSet.Add(apps.NameFromString(name))
	if existed {
		fmt.Fprintf(GinkgoWriter, "Recoverable error: app %s was already created\n", name)
	}

	for _, option := range options {
		if option == "--no-remote" {
			noRemote = true
		}
	}

	if !noRemote {
		Eventually(sess).Should(Say("Git remote deis added"))
	}
	Eventually(sess).Should(Say("remote available at "))
	Eventually(sess).Should(Exit(0))
	return sess
}

func destroyApp(profile string, app App) *Session {
	sess, err := start("deis apps:destroy --app=%s --confirm=%s", profile, app.Name, app.Name)
	Expect(err).NotTo(HaveOccurred())
	sess.Wait(defaultMaxTimeout)
	Eventually(sess).Should(Say("Destroying %s...", app.Name))
	Eventually(sess).Should(Say(`done in `))
	Eventually(sess).Should(Exit(0))
	return sess
}

func deployApp(profile string, name string) App {
	app := App{Name: name, URL: strings.Replace(getController(), "deis", name, 1)}
	sess, err := start("GIT_SSH=%s git push deis master", profile, gitSSH)
	Expect(err).NotTo(HaveOccurred())
	sess.Wait(defaultMaxTimeout)
	// output := string(sess.Out.Contents())
	// Expect(output).To(MatchRegexp(`Done, %s:v\d deployed to Deis`, app.Name))
	Eventually(sess).Should(Exit(0))
	return app
}

// cmdWithRetry runs the provided <cmd> repeatedly, once a second up to the
// supplied <timeout> until the <cmd> result contains the <expectedResult>
// An example use of this utility would be curl-ing a url and waiting
// until the response code matches the expected response
func cmdWithRetry(cmd Cmd, expectedResult string, timeout int) bool {
	var result string
	fmt.Fprintf(GinkgoWriter, "Waiting up to %d seconds for `%s` to return %s...\n", timeout, cmd.CommandLineString, expectedResult)
	for i := 0; i < timeout; i++ {
		sess, err := startCmd(cmd)
		Expect(err).NotTo(HaveOccurred())
		result = string(sess.Wait().Out.Contents())
		if strings.Contains(result, expectedResult) {
			return true
		}
		time.Sleep(1 * time.Second)
	}
	fmt.Fprintf(GinkgoWriter, "FAIL: '%s' does not match expected result of '%s'\n", result, expectedResult)
	return false
}

// gitInit simply invokes 'git init' and verifies the command is successful
func gitInit() {
	cmd, err := start("git init", "")
	Expect(err).NotTo(HaveOccurred())
	Eventually(cmd).Should(Say("Initialized empty Git repository"))
}

// gitClean destroys the .git directory and verifies the command is successful
func gitClean() {
	cmd, err := start("rm -rf .git", "")
	Expect(err).NotTo(HaveOccurred())
	Eventually(cmd).Should(Exit(0))
}

func initTestData(cl *controller.Client) TestData {
	randSuffix := rand.Intn(100000)
	username := fmt.Sprintf("test-%d", randSuffix)
	password := "asdf1234"
	email := fmt.Sprintf("test-%d@deis.io", randSuffix)
	keyName := fmt.Sprintf("deiskey-%v", randSuffix)

	_, regErr := controller.RegisterOrLogin(cl, username, password, email)
	Expect(regErr).To(BeNil())

	keyPath := createKey(username, keyName)
	// Write out a git+ssh wrapper file to avoid known_hosts warnings
	gitSSH = path.Join(testHome, username, ".ssh", "git-ssh")
	sshFlags := "-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
	if debug {
		sshFlags = sshFlags + " -v"
	}
	ioutil.WriteFile(gitSSH, []byte(fmt.Sprintf(
		"#!/bin/sh\nSSH_ORIGINAL_COMMAND=\"ssh $@\"\nexec /usr/bin/ssh %s -i %s \"$@\"\n",
		sshFlags, keyPath)), 0777)

	sess, err := start("deis keys:add %s.pub", username, keyPath)
	Eventually(sess, defaultMaxTimeout).Should(Say("Uploading %s.pub to deis... done", keyName))
	Eventually(sess).Should(Exit(0))
	Expect(err).NotTo(HaveOccurred())

	return TestData{
		Username:      username,
		Password:      password,
		Email:         email,
		KeyName:       keyName,
		KeyPath:       keyPath,
		ControllerURL: getController(),
		Profile:       username,
		ProfilePath:   profilePath,
	}
}
